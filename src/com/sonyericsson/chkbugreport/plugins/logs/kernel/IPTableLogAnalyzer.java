package com.sonyericsson.chkbugreport.plugins.logs.kernel;

import com.sonyericsson.chkbugreport.BugReportModule;
import com.sonyericsson.chkbugreport.doc.Chapter;
import com.sonyericsson.chkbugreport.doc.ShadedValue;
import com.sonyericsson.chkbugreport.doc.Table;
import com.sonyericsson.chkbugreport.util.Util;

import java.util.HashMap;
import java.util.Vector;
import java.util.regex.Pattern;

/**
 * Parses the logs generated by iptables to create statistics
 * e.g. log:
 *   "OUT IN= OUT=rmnet_usb0 SRC=10.143.3.219 DST=81.0.212.201 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=57017 DPT=80 SEQ=3467384767 ACK=683353950 WINDOW=229 RES=0x00 ACK URGP=0"
 *
 */
/* package */ class IPTableLogAnalyzer {

    private LogData mLogData;
    private BugReportModule mMod;
    private KernelLogLines mLogs;
    private Vector<Packet> mPackets = new Vector<Packet>();

    public IPTableLogAnalyzer(LogData logData, BugReportModule mod, KernelLogLines logs) {
        mLogData = logData;
        mMod = mod;
        mLogs = logs;
    }

    public void run() {
        // Parse all packets
        Pattern p = Pattern.compile(".*IN=.* OUT=.* SRC=.* DST=.* LEN=.*");
        for (KernelLogLine ll : mLogs) {
            if (p.matcher(ll.mMsg).matches()) {
                Packet pkt = parse(ll);
                if (pkt.ok) {
                    mPackets.add(pkt);
                }
            }
        }

        if (mPackets.isEmpty()) {
            return;
        }

        // Analyze packets
        createSimpleStats();
    }

    private Packet parse(KernelLogLine ll) {
        Packet pkt = parseAttrs(ll.mMsg);
        pkt.ts = ll.ts;
        pkt.realTs = ll.getRealTs();
        pkt.log = ll;
        return pkt;
    }

    private Packet parseAttrs(String log) {
        Packet pkt = new Packet();
        log = Util.strip(log);

        // Extract prefix
        int idx = log.indexOf("IN=");
        if (idx > 0) {
            pkt.prefix = log.substring(0, idx);
            log = log.substring(idx);
        }

        // Extract referenced packet
        idx = log.indexOf('[');
        if (idx > 0) {
            int idx2 = log.lastIndexOf(']');
            if (idx2 > idx) {
                pkt.ref = parseAttrs(log.substring(idx + 1, idx2 - 1));
            }
            log = log.substring(0, idx - 1);
        }

        // Split log line and extract attributes and flags
        String fields[] = log.split(" ");
        for (String f : fields) {
            if (f.contains("=")) {
                String kv[] = f.split("=", 2);
                pkt.put(kv[0], kv[1]);
            } else {
                pkt.addFlag(f);
            }
        }

        // Check parsed packet
        pkt.check();
        return pkt;
    }

    private void createSimpleStats() {
        // Collect data
        HashMap<String, PacketStat> inStats = new HashMap<String, PacketStat>();
        HashMap<String, PacketStat> outStats = new HashMap<String, PacketStat>();
        for (Packet p : mPackets) {
            String prefix = p.prefix == null ? "<null>" : p.prefix;
            HashMap<String, PacketStat> stats = p.isInput() ? inStats : outStats;
            PacketStat stat = stats.get(prefix);
            if (stat == null) {
                stat = new PacketStat();
                stat.prefix = prefix;
                stat.type = p.isInput() ? "IN" : "OUT";
                stats.put(prefix, stat);
            }
            stat.count++;
            stat.bytes += p.len;
        }

        if (inStats.isEmpty() && outStats.isEmpty()) {
            return; // No data to show
        }

        Chapter ch = new Chapter(mMod, "Packet statistics");
        mLogData.addChapter(ch);

        if (!inStats.isEmpty()) {
            createStatsTable(ch, inStats, "Incomming packets");
        }
        if (!outStats.isEmpty()) {
            createStatsTable(ch, outStats, "Outgoing packets");
        }
    }

    private void createStatsTable(Chapter ch, HashMap<String, PacketStat> stats, String title) {
        // Create tables
        Table tbl = new Table(Table.FLAG_SORT, ch);
        tbl.addColumn("Type", Table.FLAG_NONE, "type varchar");
        tbl.addColumn("Prefix", Table.FLAG_NONE, "prefix varchar");
        tbl.addColumn("Count", Table.FLAG_ALIGN_RIGHT, "count int");
        tbl.addColumn("Bytes", Table.FLAG_ALIGN_RIGHT, "bytes int");
        tbl.begin();
        for (PacketStat stat : stats.values()) {
            tbl.addData(stat.type);
            tbl.addData(stat.prefix);
            tbl.addData(new ShadedValue(stat.count));
            tbl.addData(new ShadedValue(stat.bytes));
        }
        tbl.end();
    }

    class PacketStat {
        String type;
        String prefix;
        int count;
        int bytes;
    }

}
