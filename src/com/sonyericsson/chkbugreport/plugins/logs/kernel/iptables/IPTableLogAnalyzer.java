package com.sonyericsson.chkbugreport.plugins.logs.kernel.iptables;

import com.sonyericsson.chkbugreport.BugReportModule;
import com.sonyericsson.chkbugreport.doc.Chapter;
import com.sonyericsson.chkbugreport.plugins.logs.kernel.KernelLogLine;
import com.sonyericsson.chkbugreport.plugins.logs.kernel.KernelLogLines;
import com.sonyericsson.chkbugreport.plugins.logs.kernel.LogData;
import com.sonyericsson.chkbugreport.util.Util;

import java.util.Vector;
import java.util.regex.Pattern;

/**
 * Parses the logs generated by iptables to create statistics
 * e.g. log:
 *   "OUT IN= OUT=rmnet_usb0 SRC=10.143.3.219 DST=81.0.212.201 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=57017 DPT=80 SEQ=3467384767 ACK=683353950 WINDOW=229 RES=0x00 ACK URGP=0"
 *
 */
public class IPTableLogAnalyzer {

    private LogData mLogData;
    private BugReportModule mMod;
    private KernelLogLines mLogs;
    private Vector<Packet> mPackets = new Vector<Packet>();

    public IPTableLogAnalyzer(LogData logData, BugReportModule mod, KernelLogLines logs) {
        mLogData = logData;
        mMod = mod;
        mLogs = logs;
    }

    public Vector<Packet> getPackets() {
        return mPackets;
    }

    public Chapter createChapter(String title) {
        Chapter ch = new Chapter(mMod, title);
        mLogData.addChapter(ch);
        return ch;
    }

    public void run() {
        // Parse all packets
        Pattern p = Pattern.compile(".*IN=.* OUT=.* SRC=.* DST=.* LEN=.*");
        Packet lastPkt = null;
        for (KernelLogLine ll : mLogs) {
            if (p.matcher(ll.msg).matches()) {
                Packet pkt = parse(ll);
                if (pkt.ok) {
                    mPackets.add(pkt);
                    // NOTE: sometimes the same packet is logged twice, so lets keep only the last one
                    if (pkt.isSame(lastPkt)) {
                        mPackets.remove(lastPkt);
                    }
                    lastPkt = pkt;
                }
            }
        }

        if (mPackets.isEmpty()) {
            return;
        }

        // Analyze packets
        new SimpleStats(this).run();
        new ResendStats(this).run();
        new ConnectionGrouping(this).run();
    }

    private Packet parse(KernelLogLine ll) {
        Packet pkt = parseAttrs(ll.msg);
        pkt.ts = ll.ts;
        pkt.realTs = ll.realTs;
        pkt.log = ll;
        return pkt;
    }

    private Packet parseAttrs(String log) {
        Packet pkt = new Packet();
        log = Util.strip(log);

        // Extract prefix
        int idx = log.indexOf("IN=");
        if (idx > 0) {
            pkt.prefix = log.substring(0, idx);
            log = log.substring(idx);
        }
        pkt.hash = log.hashCode();

        // Extract referenced packet
        idx = log.indexOf('[');
        if (idx > 0) {
            int idx2 = log.lastIndexOf(']');
            if (idx2 > idx) {
                pkt.ref = parseAttrs(log.substring(idx + 1, idx2 - 1));
            }
            log = log.substring(0, idx - 1);
        }

        // Split log line and extract attributes and flags
        String fields[] = log.split(" ");
        for (String f : fields) {
            if (f.contains("=")) {
                String kv[] = f.split("=", 2);
                pkt.put(kv[0], kv[1]);
            } else {
                pkt.addFlag(f);
            }
        }

        // Check parsed packet
        pkt.check();
        return pkt;
    }

}
